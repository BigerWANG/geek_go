package goroutine

import "testing"

/*
关于协程的问题
1)如果一个协程运行的时间特别长，把整个processor 都占住了会怎样?
在go程序启动的时候会有一个守护线程，会对processor做一个计数，会记录每个P完成的协程的数量，
当发现一段时间某个P完成的协程数量没有发生变化的时候，这时守护线程就会往这个协程的任务栈里插入一个特殊的标记，
当协程运行的时候读到这个标记，就会把自己中断下来，把自己插到这个协程队列的队尾，然后别的协程就可以去运行了

2)go中的协程是怎么被调度的
Go中拥有强大的用于调度 goroutine、对接系统级线程的调度器。
这个调度器是 Go 语言运行时系统的重要组成部分，它主要负责统筹调配 Go 并发编程模型中的三个主要元素，
即：G（goroutine 的缩写）、P（processor 的缩写）和 M（machine 的缩写）。其中的 M 指代的就是系统级线程。
而 P 指的是一种可以承载若干个 G，且能够使这些 G 适时地与 M 进行对接，并得到真正运行的中介。
从宏观上说，G 和 M 由于 P 的存在可以呈现出多对多的关系。当一个正在与某个 M 对接并运行着的 G，
需要因某个事件（比如等待 I/O 或锁的解除）而暂停运行的时候，调度器总会及时地发现，
并把这个 G 与那个 M 分离开，以释放计算资源供那些等待运行的 G 使用。而当一个 G 需要恢复运行的时候，
调度器又会尽快地为它寻找空闲的计算资源（包括 M）并安排运行。另外，当 M 不够用时，调度器会帮我们向操作系统申请新的系统级线程，
而当某个 M 已无用时，调度器又会负责把它及时地销毁掉。
*/



/*
根据goroutine的特性这段代码的最可能有两种输出

1，输出10 行10
go 语句在执行完毕后不会等待go函数的执行，而是直接去执行下一条语句
所以go函数往往会比go主协程滞后一些，所以有可能会在主goroutine做完循环之后，将结果输出出来

2,什么也不输出
一旦主goroutine中的代码执行完毕，当前的go程序就会结束运行
所以可能是在主goroutine执行完毕后还没来得及执行其他goroutine就直接退出了
*/
func TestGo(t *testing.T) {
	for i:=1; i<10; i++{
		go func() {
			t.Log(i)
		}()
	}

}

